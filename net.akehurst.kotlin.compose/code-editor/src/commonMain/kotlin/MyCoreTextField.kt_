/*
 * Copyright 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Modified by Dr. D.H. Akehurst adding the onScoll argument
 * as also done by Alex/n34t0 in [https://github.com/n34t0/compose-code-editor]
 *
 *//*


//https://github.com/JetBrains/kotlin/blob/d39a7e59a75a464c656af6bed9718c427e91f236/compiler/frontend/src/org/jetbrains/kotlin/diagnostics/rendering/DefaultErrorMessages.java
@file:Suppress("UNUSED", "INVISIBLE_MEMBER", "INVISIBLE_REFERENCE", "EQUALS_MISSING", "CANNOT_OVERRIDE_INVISIBLE_MEMBER")

package androidx.compose.foundation.text

import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.gestures.Orientation
import androidx.compose.foundation.interaction.Interaction
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.relocation.BringIntoViewRequester
import androidx.compose.foundation.relocation.bringIntoViewRequester
import androidx.compose.foundation.text.selection.*
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.snapshots.Snapshot
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.focus.FocusManager
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Paint
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.input.key.onPreviewKeyEvent
import androidx.compose.ui.layout.*
import androidx.compose.ui.platform.*
import androidx.compose.ui.semantics.*
import androidx.compose.ui.text.*
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.input.*
import androidx.compose.ui.unit.Constraints
import androidx.compose.ui.unit.Density
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.max
import kotlin.math.roundToInt

*/
/**
 * Base composable that enables users to edit text via hardware or software keyboard.
 *
 * This composable provides basic text editing functionality, however does not include any
 * decorations such as borders, hints/placeholder.
 *
 * If the editable text is larger than the size of the container, the vertical scrolling
 * behaviour will be automatically applied. To enable a single line behaviour with horizontal
 * scrolling instead, set the [maxLines] parameter to 1, [softWrap] to false, and
 * [ImeOptions.singleLine] to true.
 *
 * Whenever the user edits the text, [onValueChange] is called with the most up to date state
 * represented by [TextFieldValue]. [TextFieldValue] contains the text entered by user, as well
 * as selection, cursor and text composition information. Please check [TextFieldValue] for the
 * description of its contents.
 *
 * It is crucial that the value provided in the [onValueChange] is fed back into [CoreTextField] in
 * order to have the final state of the text being displayed. Example usage:
 *
 * Please keep in mind that [onValueChange] is useful to be informed about the latest state of the
 * text input by users, however it is generally not recommended to modify the values in the
 * [TextFieldValue] that you get via [onValueChange] callback. Any change to the values in
 * [TextFieldValue] may result in a context reset and end up with input session restart. Such
 * a scenario would cause glitches in the UI or text input experience for users.
 *
 * @param value The [androidx.compose.ui.text.input.TextFieldValue] to be shown in the [CoreTextField].
 * @param onValueChange Called when the input service updates the values in [TextFieldValue].
 * @param modifier optional [Modifier] for this text field.
 * @param textStyle Style configuration that applies at character level such as color, font etc.
 * @param visualTransformation The visual transformation filter for changing the visual
 * representation of the input. By default no visual transformation is applied.
 * @param onTextLayout Callback that is executed when a new text layout is calculated. A
 * [TextLayoutResult] object that callback provides contains paragraph information, size of the
 * text, baselines and other details. The callback can be used to add additional decoration or
 * functionality to the text. For example, to draw a cursor or selection around the text.
 * @param interactionSource the [MutableInteractionSource] representing the stream of
 * [Interaction]s for this CoreTextField. You can create and pass in your own remembered
 * [MutableInteractionSource] if you want to observe [Interaction]s and customize the
 * appearance / behavior of this CoreTextField in different [Interaction]s.
 * @param cursorBrush [Brush] to paint cursor with. If [SolidColor] with [Color.Unspecified]
 * provided, there will be no cursor drawn
 * @param softWrap Whether the text should break at soft line breaks. If false, the glyphs in the
 * text will be positioned as if there was unlimited horizontal space.
 * @param maxLines The maximum height in terms of maximum number of visible lines. It is required
 * that 1 <= [minLines] <= [maxLines].
 * @param minLines The minimum height in terms of minimum number of visible lines. It is required
 * that 1 <= [minLines] <= [maxLines].
 * @param imeOptions Contains different IME configuration options.
 * @param keyboardActions when the input service emits an IME action, the corresponding callback
 * is called. Note that this IME action may be different from what you specified in
 * [KeyboardOptions.imeAction].
 * @param enabled controls the enabled state of the text field. When `false`, the text
 * field will be neither editable nor focusable, the input of the text field will not be selectable
 * @param readOnly controls the editable state of the [CoreTextField]. When `true`, the text
 * field can not be modified, however, a user can focus it and copy text from it. Read-only text
 * fields are usually used to display pre-filled forms that user can not edit
 * @param decorationBox Composable lambda that allows to add decorations around text field, such
 * as icon, placeholder, helper messages or similar, and automatically increase the hit target area
 * of the text field. To allow you to control the placement of the inner text field relative to your
 * decorations, the text field implementation will pass in a framework-controlled composable
 * parameter "innerTextField" to the decorationBox lambda you provide. You must call
 * innerTextField exactly once.
 */

@file:Suppress(
    //"DEPRECATION",
    "UNUSED",
    "INVISIBLE_MEMBER",
    "INVISIBLE_REFERENCE",
    "EQUALS_MISSING",
    "CANNOT_OVERRIDE_INVISIBLE_MEMBER"
)
package androidx.compose.foundation.text.mine

import androidx.compose.foundation.text.*
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.text.*
import androidx.compose.foundation.gestures.Orientation
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.interaction.Interaction
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.overscroll
import androidx.compose.foundation.relocation.BringIntoViewRequester
import androidx.compose.foundation.relocation.bringIntoViewRequester
import androidx.compose.foundation.text.ContextMenuArea
import androidx.compose.foundation.text.CursorHandle
import androidx.compose.foundation.text.DefaultMinLines
import androidx.compose.foundation.text.KeyboardActionRunner
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.text.LocalAutofillHighlightColor
import androidx.compose.foundation.text.TextDelegate
import androidx.compose.foundation.text.TextFieldDelegate
import androidx.compose.foundation.text.TextFieldScrollerPosition
import androidx.compose.foundation.text.TextLayoutResultProxy
import androidx.compose.foundation.text.UndoManager
import androidx.compose.foundation.text.cancelsTextSelection
import androidx.compose.foundation.text.ceilToIntPx
import androidx.compose.foundation.text.computeSizeForDefaultText
import androidx.compose.foundation.text.cursor
import androidx.compose.foundation.text.filterWithValidation
import androidx.compose.foundation.text.handwriting.stylusHandwriting
import androidx.compose.foundation.text.heightInLines
import androidx.compose.foundation.text.input.internal.CoreTextFieldSemanticsModifier
import androidx.compose.foundation.text.input.internal.legacyTextInputAdapter
import androidx.compose.foundation.text.input.internal.legacyTextInputServiceAdapterAndService
import androidx.compose.foundation.text.interceptDPadAndMoveFocus
import androidx.compose.foundation.text.rememberClipboardEventsHandler
import androidx.compose.foundation.text.rememberTextFieldOverscrollEffect
import androidx.compose.foundation.text.selection.LocalTextSelectionColors
import androidx.compose.foundation.text.selection.OffsetProvider
import androidx.compose.foundation.text.selection.SelectionHandleAnchor
import androidx.compose.foundation.text.selection.SelectionHandleInfo
import androidx.compose.foundation.text.selection.SelectionHandleInfoKey
import androidx.compose.foundation.text.selection.SimpleLayout
import androidx.compose.foundation.text.selection.TextFieldSelectionHandle
import androidx.compose.foundation.text.selection.TextFieldSelectionManager
import androidx.compose.foundation.text.selection.isSelectionHandleInVisibleBound
import androidx.compose.foundation.text.selection.selectionGestureInput
import androidx.compose.foundation.text.selection.textFieldMagnifier
import androidx.compose.foundation.text.selection.updateSelectionTouchMode
import androidx.compose.foundation.text.textFieldFocusModifier
import androidx.compose.foundation.text.textFieldKeyInput
import androidx.compose.foundation.text.textFieldMinSize
import androidx.compose.foundation.text.textFieldPointer
import androidx.compose.foundation.text.textFieldScroll
import androidx.compose.foundation.text.textFieldScrollable
import androidx.compose.foundation.text.then
import androidx.compose.foundation.text.updateTextDelegate
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.DontMemoize
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.RecomposeScope
import androidx.compose.runtime.currentRecomposeScope
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.rememberUpdatedState
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.runtime.snapshotFlow
import androidx.compose.runtime.snapshots.Snapshot
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.focus.FocusManager
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Rect
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Paint
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.hapticfeedback.HapticFeedback
import androidx.compose.ui.input.key.onPreviewKeyEvent
import androidx.compose.ui.input.pointer.pointerHoverIcon
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.FirstBaseline
import androidx.compose.ui.layout.IntrinsicMeasurable
import androidx.compose.ui.layout.IntrinsicMeasureScope
import androidx.compose.ui.layout.LastBaseline
import androidx.compose.ui.layout.Layout
import androidx.compose.ui.layout.LayoutCoordinates
import androidx.compose.ui.layout.Measurable
import androidx.compose.ui.layout.MeasurePolicy
import androidx.compose.ui.layout.MeasureResult
import androidx.compose.ui.layout.MeasureScope
import androidx.compose.ui.layout.onGloballyPositioned
import androidx.compose.ui.platform.Clipboard
import androidx.compose.ui.platform.LocalClipboard
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.platform.LocalFontFamilyResolver
import androidx.compose.ui.platform.LocalHapticFeedback
import androidx.compose.ui.platform.LocalSoftwareKeyboardController
import androidx.compose.ui.platform.LocalTextToolbar
import androidx.compose.ui.platform.LocalWindowInfo
import androidx.compose.ui.platform.SoftwareKeyboardController
import androidx.compose.ui.platform.TextToolbar
import androidx.compose.ui.semantics.semantics
import androidx.compose.ui.text.AnnotatedString
import androidx.compose.ui.text.TextLayoutResult
import androidx.compose.ui.text.TextRange
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.input.EditProcessor
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.ImeOptions
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.OffsetMapping
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.text.input.TextInputService
import androidx.compose.ui.text.input.TextInputSession
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.unit.Constraints
import androidx.compose.ui.unit.Density
import androidx.compose.ui.unit.DpSize
import androidx.compose.ui.unit.dp
import androidx.compose.ui.util.fastForEach
import androidx.compose.ui.util.fastMap
import androidx.compose.ui.util.fastRoundToInt
import kotlinx.coroutines.CoroutineScope
import kotlin.math.max
import kotlinx.coroutines.CoroutineStart
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlin.comparisons.then

/**
 * Base composable that enables users to edit text via hardware or software keyboard.
 *
 * This composable provides basic text editing functionality, however does not include any
 * decorations such as borders, hints/placeholder.
 *
 * If the editable text is larger than the size of the container, the vertical scrolling behaviour
 * will be automatically applied. To enable a single line behaviour with horizontal scrolling
 * instead, set the [maxLines] parameter to 1, [softWrap] to false, and [ImeOptions.singleLine] to
 * true.
 *
 * Whenever the user edits the text, [onValueChange] is called with the most up to date state
 * represented by [TextFieldValue]. [TextFieldValue] contains the text entered by user, as well as
 * selection, cursor and text composition information. Please check [TextFieldValue] for the
 * description of its contents.
 *
 * It is crucial that the value provided in the [onValueChange] is fed back into [CoreTextField] in
 * order to have the final state of the text being displayed. Example usage:
 *
 * Please keep in mind that [onValueChange] is useful to be informed about the latest state of the
 * text input by users, however it is generally not recommended to modify the values in the
 * [TextFieldValue] that you get via [onValueChange] callback. Any change to the values in
 * [TextFieldValue] may result in a context reset and end up with input session restart. Such a
 * scenario would cause glitches in the UI or text input experience for users.
 *
 * @param value The [androidx.compose.ui.text.input.TextFieldValue] to be shown in the
 *   [CoreTextField].
 * @param onValueChange Called when the input service updates the values in [TextFieldValue].
 * @param modifier optional [Modifier] for this text field.
 * @param textStyle Style configuration that applies at character level such as color, font etc.
 * @param visualTransformation The visual transformation filter for changing the visual
 *   representation of the input. By default no visual transformation is applied.
 * @param onTextLayout Callback that is executed when a new text layout is calculated. A
 *   [TextLayoutResult] object that callback provides contains paragraph information, size of the
 *   text, baselines and other details. The callback can be used to add additional decoration or
 *   functionality to the text. For example, to draw a cursor or selection around the text.
 * @param interactionSource the [MutableInteractionSource] representing the stream of [Interaction]s
 *   for this CoreTextField. You can create and pass in your own remembered
 *   [MutableInteractionSource] if you want to observe [Interaction]s and customize the appearance /
 *   behavior of this CoreTextField in different [Interaction]s.
 * @param cursorBrush [Brush] to paint cursor with. If [SolidColor] with [Color.Unspecified]
 *   provided, there will be no cursor drawn
 * @param softWrap Whether the text should break at soft line breaks. If false, the glyphs in the
 *   text will be positioned as if there was unlimited horizontal space.
 * @param maxLines The maximum height in terms of maximum number of visible lines. It is required
 *   that 1 <= [minLines] <= [maxLines].
 * @param minLines The minimum height in terms of minimum number of visible lines. It is required
 *   that 1 <= [minLines] <= [maxLines].
 * @param imeOptions Contains different IME configuration options.
 * @param keyboardActions when the input service emits an IME action, the corresponding callback is
 *   called. Note that this IME action may be different from what you specified in
 *   [KeyboardOptions.imeAction].
 * @param enabled controls the enabled state of the text field. When `false`, the text field will be
 *   neither editable nor focusable, the input of the text field will not be selectable
 * @param readOnly controls the editable state of the [CoreTextField]. When `true`, the text field
 *   can not be modified, however, a user can focus it and copy text from it. Read-only text fields
 *   are usually used to display pre-filled forms that user can not edit
 * @param decorationBox Composable lambda that allows to add decorations around text field, such as
 *   icon, placeholder, helper messages or similar, and automatically increase the hit target area
 *   of the text field. To allow you to control the placement of the inner text field relative to
 *   your decorations, the text field implementation will pass in a framework-controlled composable
 *   parameter "innerTextField" to the decorationBox lambda you provide. You must call
 *   innerTextField exactly once.
 */
@OptIn(ExperimentalFoundationApi::class)
@Composable
internal fun MyCoreTextField(
    value: TextFieldValue,
    onValueChange: (TextFieldValue) -> Unit,
    modifier: Modifier = Modifier,
    textStyle: TextStyle = TextStyle.Default,
    visualTransformation: VisualTransformation = VisualTransformation.None,
    onTextLayout: (TextLayoutResult) -> Unit = {},
    interactionSource: MutableInteractionSource? = null,
    cursorBrush: Brush = SolidColor(Color.Unspecified),
    softWrap: Boolean = true,
    maxLines: Int = Int.MAX_VALUE,
    minLines: Int = DefaultMinLines,
    imeOptions: ImeOptions = ImeOptions.Default,
    keyboardActions: KeyboardActions = KeyboardActions.Default,
    enabled: Boolean = true,
    readOnly: Boolean = false,
    @Suppress("ComposableLambdaParameterPosition")
    decorationBox: @Composable (innerTextField: @Composable () -> Unit) -> Unit =
        @Composable { innerTextField -> innerTextField() },
    textScrollerPosition: TextFieldScrollerPosition? = null,
    focusRequester: FocusRequester = FocusRequester()
) {

    val (legacyTextInputServiceAdapter, textInputService) =
        legacyTextInputServiceAdapterAndService()

    // CompositionLocals
    val density = LocalDensity.current
    val fontFamilyResolver = LocalFontFamilyResolver.current
    val selectionBackgroundColor = LocalTextSelectionColors.current.backgroundColor
    val focusManager = LocalFocusManager.current
    val windowInfo = LocalWindowInfo.current
    val keyboardController = LocalSoftwareKeyboardController.current

    // Scroll state
    val singleLine = maxLines == 1 && !softWrap && imeOptions.singleLine
    val orientation = if (singleLine) Orientation.Horizontal else Orientation.Vertical
    val scrollerPosition =
        textScrollerPosition
            ?: rememberSaveable(orientation, saver = TextFieldScrollerPosition.Saver) {
                TextFieldScrollerPosition(orientation)
            }
    if (scrollerPosition.orientation != orientation) {
        throw IllegalArgumentException(
            "Mismatching scroller orientation; " +
                    (if (orientation == Orientation.Vertical)
                        "only single-line, non-wrap text fields can scroll horizontally"
                    else "single-line, non-wrap text fields can only scroll horizontally")
        )
    }

    // State
    val transformedText =
        remember(value, visualTransformation) {
            val transformed = visualTransformation.filterWithValidation(value.annotatedString)

            value.composition?.let { TextFieldDelegate.applyCompositionDecoration(it, transformed) }
                ?: transformed
        }

    val visualText = transformedText.text
    val offsetMapping = transformedText.offsetMapping

    // If developer doesn't pass new value to TextField, recompose won't happen but internal state
    // and IME may think it is updated. To fix this inconsistent state, enforce recompose.
    val scope = currentRecomposeScope
    val state =
        remember(keyboardController) {
            LegacyTextFieldState(
                TextDelegate(
                    text = visualText,
                    style = textStyle,
                    softWrap = softWrap,
                    density = density,
                    fontFamilyResolver = fontFamilyResolver
                ),
                recomposeScope = scope,
                keyboardController = keyboardController
            )
        }
    state.update(
        value.annotatedString,
        visualText,
        textStyle,
        softWrap,
        density,
        fontFamilyResolver,
        onValueChange,
        keyboardActions,
        focusManager,
        selectionBackgroundColor
    )

    // notify the EditProcessor of value every recomposition
    state.processor.reset(value, state.inputSession)

    val undoManager = remember { UndoManager() }
    undoManager.snapshotIfNeeded(value)

    val coroutineScope = rememberCoroutineScope()
    val bringIntoViewRequester = remember { BringIntoViewRequester() }

    val manager = remember { TextFieldSelectionManager(undoManager) }
    manager.offsetMapping = offsetMapping
    manager.visualTransformation = visualTransformation
    manager.onValueChange = state.onValueChange
    manager.state = state
    manager.value = value
    manager.clipboard = LocalClipboard.current
    manager.coroutineScope = coroutineScope
    manager.textToolbar = LocalTextToolbar.current
    manager.hapticFeedBack = LocalHapticFeedback.current
    manager.focusRequester = focusRequester
    manager.editable = !readOnly
    manager.enabled = enabled

    // TODO: upstreaming https://youtrack.jetbrains.com/issue/CMP-7517/Upstream-rememberClipboardEventsHandler
    rememberClipboardEventsHandler(
        isEnabled = state.hasFocus,
        onCopy = { manager.onCopyWithResult() },
        onCut = { manager.onCutWithResult() },
        onPaste = { manager.paste(AnnotatedString(it)) }
    )

    // Focus
    val focusModifier =
        Modifier.textFieldFocusModifier(
            enabled = enabled,
            focusRequester = focusRequester,
            interactionSource = interactionSource
        ) {
            if (state.hasFocus == it.isFocused) {
                return@textFieldFocusModifier
            }
            state.hasFocus = it.isFocused

            if (state.hasFocus && enabled && !readOnly) {
                startInputSession(textInputService, state, value, imeOptions, offsetMapping)
            } else {
                endInputSession(state)
            }

            // The focusable modifier itself will request the entire focusable be brought into view
            // when it gains focus â€“ in this case, that's the decoration box. However, since text
            // fields may have their own internal scrolling, and the decoration box can do anything,
            // we also need to specifically request that the cursor itself be brought into view.
            // TODO(b/216790855) If this request happens after the focusable's request, the field
            //  will only be scrolled far enough to show the cursor, _not_ the entire decoration
            //  box.
            if (it.isFocused) {
                state.layoutResult?.let { layoutResult ->
                    coroutineScope.launch {
                        bringIntoViewRequester.bringSelectionEndIntoView(
                            value,
                            state.textDelegate,
                            layoutResult.value,
                            offsetMapping
                        )
                    }
                }
            }
            if (!it.isFocused) manager.deselect()
        }

    // Hide the keyboard if made disabled or read-only while focused (b/237308379).
    val writeable by rememberUpdatedState(enabled && !readOnly)
    LaunchedEffect(Unit) {
        try {
            snapshotFlow { writeable }
                .collect { writeable ->
                    // When hasFocus changes, the session will be stopped/started in the focus
                    // handler so we don't need to handle its changes here.
                    if (writeable && state.hasFocus) {
                        startInputSession(
                            textInputService,
                            state,
                            manager.value,
                            imeOptions,
                            manager.offsetMapping
                        )
                    } else {
                        endInputSession(state)
                    }
                }
        } finally {
            // TODO(b/230536793) This is a workaround since we don't get an explicit focus blur
            //  event when the text field is removed from the composition entirely.
            endInputSession(state)
        }
    }

    val pointerModifier = Modifier.textFieldPointer(
        manager, enabled, interactionSource, state, focusRequester, readOnly, offsetMapping
    )

    val drawModifier =
        Modifier.drawBehind {
            state.layoutResult?.let { layoutResult ->
                drawIntoCanvas { canvas ->
                    TextFieldDelegate.draw(
                        canvas,
                        value,
                        state.selectionPreviewHighlightRange,
                        state.deletionPreviewHighlightRange,
                        offsetMapping,
                        layoutResult.value,
                        state.highlightPaint,
                        state.selectionBackgroundColor
                    )
                }
            }
        }

    val onPositionedModifier =
        Modifier.onGloballyPositioned {
            state.layoutCoordinates = it
            state.layoutResult?.innerTextFieldCoordinates = it
            if (enabled) {
                if (state.handleState == HandleState.Selection) {
                    if (state.showFloatingToolbar && windowInfo.isWindowFocused) {
                        manager.showSelectionToolbar()
                    } else {
                        manager.hideSelectionToolbar()
                    }
                    state.showSelectionHandleStart =
                        manager.isSelectionHandleInVisibleBound(isStartHandle = true)
                    state.showSelectionHandleEnd =
                        manager.isSelectionHandleInVisibleBound(isStartHandle = false)
                    state.showCursorHandle = value.selection.collapsed
                } else if (state.handleState == HandleState.Cursor) {
                    state.showCursorHandle =
                        manager.isSelectionHandleInVisibleBound(isStartHandle = true)
                }
                notifyFocusedRect(state, value, offsetMapping)
                state.layoutResult?.let { layoutResult ->
                    state.inputSession?.let { inputSession ->
                        if (state.hasFocus) {
                            TextFieldDelegate.updateTextLayoutResult(
                                inputSession,
                                value,
                                offsetMapping,
                                layoutResult
                            )
                        }
                    }
                }
            }
        }

    val isPassword = visualTransformation is PasswordVisualTransformation
    val semanticsModifier =
        CoreTextFieldSemanticsModifier(
            transformedText,
            value,
            state,
            readOnly,
            enabled,
            isPassword,
            offsetMapping,
            manager,
            imeOptions,
            focusRequester
        )

    val showCursor = enabled && !readOnly && windowInfo.isWindowFocused && !state.hasHighlight()
    val cursorModifier = Modifier.cursor(state, value, offsetMapping, cursorBrush, showCursor)

    DisposableEffect(manager) { onDispose { manager.hideSelectionToolbar() } }

    DisposableEffect(imeOptions) {
        if (state.hasFocus) {
            state.inputSession =
                TextFieldDelegate.restartInput(
                    textInputService = textInputService,
                    value = value,
                    editProcessor = state.processor,
                    imeOptions = imeOptions,
                    onValueChange = state.onValueChange,
                    onImeActionPerformed = state.onImeActionPerformed
                )
        }
        onDispose { /* do nothing */ }
    }

    val textKeyInputModifier =
        Modifier.textFieldKeyInput(
            state = state,
            manager = manager,
            value = value,
            onValueChange = state.onValueChange,
            editable = !readOnly,
            singleLine = maxLines == 1,
            offsetMapping = offsetMapping,
            undoManager = undoManager,
            imeAction = imeOptions.imeAction,
        )

    val handwritingEnabled =
        imeOptions.keyboardType != KeyboardType.Password &&
                imeOptions.keyboardType != KeyboardType.NumberPassword
    val stylusHandwritingModifier =
        Modifier.stylusHandwriting(writeable, handwritingEnabled) {
            // If this is a password field, we can't trigger handwriting.
            // The expected behavior is 1) request focus 2) show software keyboard.
            // Note: TextField will show software keyboard automatically when it
            // gain focus. 3) show a toast message telling that handwriting is not
            // supported for password fields. TODO(b/335294152)
            if (handwritingEnabled) {
                // TextInputService is calling LegacyTextInputServiceAdapter under the
                // hood.  And because it's a public API, startStylusHandwriting is added
                // to legacyTextInputServiceAdapter instead.
                // startStylusHandwriting may be called before the actual input
                // session starts when the editor is not focused, this is handled
                // internally by the LegacyTextInputServiceAdapter.
                legacyTextInputServiceAdapter.startStylusHandwriting()
            }
        }

    val autofillHighlightColor = LocalAutofillHighlightColor.current
    val drawDecorationModifier =
        Modifier.drawBehind {
            if (state.autofillHighlightOn || state.justAutofilled) {
                drawRect(color = autofillHighlightColor)
            }
        }

    val overscrollEffect = rememberTextFieldOverscrollEffect()

    // Modifiers that should be applied to the outer text field container. Usually those include
    // gesture and semantics modifiers.
    val decorationBoxModifier =
        modifier
            .then(drawDecorationModifier)
            .legacyTextInputAdapter(legacyTextInputServiceAdapter, state, manager)
            .then(stylusHandwritingModifier)
            .then(focusModifier)
            .interceptDPadAndMoveFocus(state, focusManager)
            .previewKeyEventToDeselectOnBack(state, manager)
            .then(textKeyInputModifier)
            .textFieldScrollable(scrollerPosition, interactionSource, enabled, overscrollEffect)
            .then(pointerModifier)
            .then(semanticsModifier)
            .onGloballyPositioned @DontMemoize { state.layoutResult?.decorationBoxCoordinates = it }

    val showHandleAndMagnifier =
        enabled && state.hasFocus && state.isInTouchMode && windowInfo.isWindowFocused
    val magnifierModifier =
        if (showHandleAndMagnifier) {
            Modifier.textFieldMagnifier(manager)
        } else {
            Modifier
        }

    CoreTextFieldRootBox(decorationBoxModifier, manager) {
        decorationBox {
            // Modifiers applied directly to the internal input field implementation. In general,
            // these will most likely include draw, layout and IME related modifiers.
            val coreTextFieldModifier =
                Modifier
                    // min height is set for maxLines == 1 in order to prevent text cuts for single
                    // line
                    // TextFields
                    .heightIn(min = state.minHeightForSingleLineField)
                    .heightInLines(textStyle = textStyle, minLines = minLines, maxLines = maxLines)
                    .overscroll(overscrollEffect)
                    .textFieldScroll(
                        scrollerPosition = scrollerPosition,
                        textFieldValue = value,
                        visualTransformation = visualTransformation,
                        textLayoutResultProvider = { state.layoutResult },
                    )
                    .then(cursorModifier)
                    .then(drawModifier)
                    .textFieldMinSize(textStyle)
                    .then(onPositionedModifier)
                    .then(magnifierModifier)
                    .bringIntoViewRequester(bringIntoViewRequester)

            SimpleLayout(coreTextFieldModifier) {
                Layout(
                    content = {},
                    measurePolicy =
                        object : MeasurePolicy {
                            override fun MeasureScope.measure(
                                measurables: List<Measurable>,
                                constraints: Constraints
                            ): MeasureResult {
                                val prevProxy =
                                    Snapshot.withoutReadObservation { state.layoutResult }
                                val prevResult = prevProxy?.value
                                val (width, height, result) =
                                    TextFieldDelegate.layout(
                                        state.textDelegate,
                                        constraints,
                                        layoutDirection,
                                        prevResult
                                    )
                                if (prevResult != result) {
                                    state.layoutResult =
                                        TextLayoutResultProxy(
                                            value = result,
                                            decorationBoxCoordinates =
                                                prevProxy?.decorationBoxCoordinates,
                                        )
                                    onTextLayout(result)
                                    notifyFocusedRect(state, value, offsetMapping)
                                }

                                // calculate the min height for single line text to prevent text
                                // cuts.
                                // for single line text maxLines puts in max height constraint based
                                // on
                                // constant characters therefore if the user enters a character that
                                // is
                                // longer (i.e. emoji or a tall script) the text is cut
                                state.minHeightForSingleLineField =
                                    with(density) {
                                        when (maxLines) {
                                            1 -> result.getLineBottom(0).ceilToIntPx()
                                            else -> 0
                                        }.toDp()
                                    }

                                return layout(
                                    width = width,
                                    height = height,
                                    alignmentLines =
                                        mapOf(
                                            FirstBaseline to result.firstBaseline.fastRoundToInt(),
                                            LastBaseline to result.lastBaseline.fastRoundToInt()
                                        )
                                ) {}
                            }

                            override fun IntrinsicMeasureScope.maxIntrinsicWidth(
                                measurables: List<IntrinsicMeasurable>,
                                height: Int
                            ): Int {
                                state.textDelegate.layoutIntrinsics(layoutDirection)
                                return state.textDelegate.maxIntrinsicWidth
                            }
                        }
                )

                SelectionToolbarAndHandles(
                    manager = manager,
                    show =
                        state.handleState != HandleState.None &&
                                state.layoutCoordinates != null &&
                                state.layoutCoordinates!!.isAttached &&
                                showHandleAndMagnifier
                )

                if (
                    state.handleState == HandleState.Cursor && !readOnly && showHandleAndMagnifier
                ) {
                    TextFieldCursorHandle(manager = manager)
                }
            }
        }
    }
}

@Composable
private fun CoreTextFieldRootBox(
    modifier: Modifier,
    manager: TextFieldSelectionManager,
    content: @Composable () -> Unit
) {
    Box(modifier, propagateMinConstraints = true) { ContextMenuArea(manager, content) }
}

@Composable
internal fun SimpleLayout(modifier: Modifier = Modifier, content: @Composable () -> Unit) {
    Layout(modifier = modifier, content = content) { measurables, constraints ->
        var width = 0
        var height = 0
        val placeables =
            measurables.fastMap { measurable ->
                val placeable = measurable.measure(constraints)
                width = max(width, placeable.width)
                height = max(height, placeable.height)
                placeable
            }
        layout(width, height) { placeables.fastForEach { placeable -> placeable.place(0, 0) } }
    }
}

/**
 * Indicates which handle is being dragged when the user is dragging on a text field handle.
 *
 * @see LegacyTextFieldState.handleState
 */
internal enum class Handle {
    Cursor,
    SelectionStart,
    SelectionEnd
}


internal class LegacyTextFieldState(
    var textDelegate: TextDelegate,
    val recomposeScope: RecomposeScope,
    val keyboardController: SoftwareKeyboardController?,
) {
    val processor = EditProcessor()
    var inputSession: TextInputSession? = null

    /**
     * This should be a state as every time we update the value we need to redraw it. state
     * observation during onDraw callback will make it work.
     */
    var hasFocus by mutableStateOf(false)

    /** Set to a non-zero value for single line TextFields in order to prevent text cuts. */
    var minHeightForSingleLineField by mutableStateOf(0.dp)

    /**
     * The last layout coordinates for the inner text field LayoutNode, used by selection and
     * notifyFocusedRect. Since this layoutCoordinates only used for relative position calculation,
     * we are guarding ourselves from using it when it's not attached.
     */
    private var _layoutCoordinates: LayoutCoordinates? = null
    var layoutCoordinates: LayoutCoordinates?
        get() = _layoutCoordinates?.takeIf { it.isAttached }
        set(value) {
            _layoutCoordinates = value
        }

    /**
     * You should be using proxy type [TextLayoutResultProxy] if you need to translate touch offset
     * into text's coordinate system. For example, if you add a gesture on top of the decoration box
     * and want to know the character in text for the given touch offset on decoration box. When you
     * don't need to shift the touch offset, you should be using `layoutResult.value` which omits
     * the proxy and calls the layout result directly. This is needed when you work with the text
     * directly, and not the decoration box. For example, cursor modifier gets position using the
     * [TextFieldValue.selection] value which corresponds to the text directly, and therefore does
     * not require the translation.
     */
    private val layoutResultState: MutableState<TextLayoutResultProxy?> = mutableStateOf(null)
    var layoutResult: TextLayoutResultProxy?
        get() = layoutResultState.value
        set(value) {
            layoutResultState.value = value
            isLayoutResultStale = false
        }

    /**
     * [textDelegate] keeps a reference to the visually transformed text that is visible to the
     * user. TextFieldState needs to have access to the underlying value that is not transformed
     * while making comparisons that test whether the user input actually changed.
     *
     * This field contains the real value that is passed by the user before it was visually
     * transformed.
     */
    var untransformedText: AnnotatedString? = null

    /**
     * The gesture detector state, to indicate whether current state is selection, cursor or
     * editing.
     *
     * In the none state, no selection or cursor handle is shown, only the cursor is shown.
     * TextField is initially in this state. To enter this state, input anything from the keyboard
     * and modify the text.
     *
     * In the selection state, there is no cursor shown, only selection is shown. To enter the
     * selection mode, just long press on the screen. In this mode, finger movement on the screen
     * changes selection instead of moving the cursor.
     *
     * In the cursor state, no selection is shown, and the cursor and the cursor handle are shown.
     * To enter the cursor state, tap anywhere within the TextField.(The TextField will stay in the
     * edit state if the current text is empty.) In this mode, finger movement on the screen moves
     * the cursor.
     */
    var handleState by mutableStateOf(HandleState.None)

    /**
     * A flag to check if the floating toolbar should show.
     *
     * This state is meant to represent the floating toolbar status regardless of if all touch
     * behaviors are disabled (like if the user is using a mouse). This is so that when touch
     * behaviors are re-enabled, the toolbar status will still reflect whether it should be shown at
     * that point.
     */
    var showFloatingToolbar by mutableStateOf(false)

    /**
     * True if the position of the selection start handle is within a visible part of the window
     * (i.e. not scrolled out of view) and the handle should be drawn.
     */
    var showSelectionHandleStart by mutableStateOf(false)

    /**
     * True if the position of the selection end handle is within a visible part of the window (i.e.
     * not scrolled out of view) and the handle should be drawn.
     */
    var showSelectionHandleEnd by mutableStateOf(false)

    /**
     * True if the position of the cursor is within a visible part of the window (i.e. not scrolled
     * out of view) and the handle should be drawn.
     */
    var showCursorHandle by mutableStateOf(false)

    /**
     * TextFieldState holds both TextDelegate and layout result. However, these two values are not
     * updated at the same time. TextDelegate is updated during composition according to new
     * arguments while layoutResult is updated during layout phase. Therefore, [layoutResult] might
     * not indicate the result of [textDelegate] at a given time during composition. This variable
     * indicates whether layout result is lacking behind the latest TextDelegate.
     */
    var isLayoutResultStale: Boolean = true
        private set

    var isInTouchMode: Boolean by mutableStateOf(true)

    private val keyboardActionRunner: KeyboardActionRunner =
        KeyboardActionRunner(keyboardController)

    /** Autofill related values we need to save between */
    var autofillHighlightOn by mutableStateOf(false)
    var justAutofilled by mutableStateOf(false)

    /**
     * DO NOT USE, use [onValueChange] instead. This is original callback provided to the TextField.
     * In order the CoreTextField to work, the recompose.invalidate() has to be called when we call
     * the callback and [onValueChange] is a wrapper that mainly does that.
     */
    private var onValueChangeOriginal: (TextFieldValue) -> Unit = {}

    val onValueChange: (TextFieldValue) -> Unit = {
        if (it.text != untransformedText?.text) {
            // Text has been changed, enter the HandleState.None and hide the cursor handle.
            handleState = HandleState.None

            // Autofill logic
            if (justAutofilled) {
                justAutofilled = false
            } else {
                autofillHighlightOn = false
            }
        }
        selectionPreviewHighlightRange = TextRange.Zero
        deletionPreviewHighlightRange = TextRange.Zero
        onValueChangeOriginal(it)
        recomposeScope.invalidate()
    }

    val onImeActionPerformed: (ImeAction) -> Unit = { imeAction ->
        keyboardActionRunner.runAction(imeAction)
    }

    /** The paint used to draw highlight backgrounds. */
    val highlightPaint: Paint = Paint()
    var selectionBackgroundColor = Color.Unspecified

    /** Range of text to be highlighted to display handwriting gesture previews from the IME. */
    var selectionPreviewHighlightRange: TextRange by mutableStateOf(TextRange.Zero)
    var deletionPreviewHighlightRange: TextRange by mutableStateOf(TextRange.Zero)

    fun hasHighlight() =
        !selectionPreviewHighlightRange.collapsed || !deletionPreviewHighlightRange.collapsed

    fun update(
        untransformedText: AnnotatedString,
        visualText: AnnotatedString,
        textStyle: TextStyle,
        softWrap: Boolean,
        density: Density,
        fontFamilyResolver: FontFamily.Resolver,
        onValueChange: (TextFieldValue) -> Unit,
        keyboardActions: KeyboardActions,
        focusManager: FocusManager,
        selectionBackgroundColor: Color
    ) {
        this.onValueChangeOriginal = onValueChange
        this.selectionBackgroundColor = selectionBackgroundColor
        this.keyboardActionRunner.apply {
            this.keyboardActions = keyboardActions
            this.focusManager = focusManager
        }
        this.untransformedText = untransformedText

        val newTextDelegate =
            updateTextDelegate(
                current = textDelegate,
                text = visualText,
                style = textStyle,
                softWrap = softWrap,
                density = density,
                fontFamilyResolver = fontFamilyResolver,
                placeholders = emptyList(),
            )

        if (textDelegate !== newTextDelegate) isLayoutResultStale = true
        textDelegate = newTextDelegate
    }
}


/** Request focus on tap. If already focused, makes sure the keyboard is requested. */
internal fun requestFocusAndShowKeyboardIfNeeded(
    state: LegacyTextFieldState,
    focusRequester: FocusRequester,
    allowKeyboard: Boolean
) {
    if (!state.hasFocus) {
        focusRequester.requestFocus()
    } else if (allowKeyboard) {
        state.keyboardController?.show()
    }
}

private fun startInputSession(
    textInputService: TextInputService,
    state: LegacyTextFieldState,
    value: TextFieldValue,
    imeOptions: ImeOptions,
    offsetMapping: OffsetMapping
) {
    state.inputSession =
        TextFieldDelegate.onFocus(
            textInputService,
            value,
            state.processor,
            imeOptions,
            state.onValueChange,
            state.onImeActionPerformed
        )
    notifyFocusedRect(state, value, offsetMapping)
}

private fun endInputSession(state: LegacyTextFieldState) {
    state.inputSession?.let { session ->
        TextFieldDelegate.onBlur(session, state.processor, state.onValueChange)
    }
    state.inputSession = null
}

/**
 * Calculates the location of the end of the current selection and requests that it be brought into
 * view using [bringCursorIntoView][BringIntoViewRequester.bringIntoView].
 *
 * Text fields have a lot of different edge cases where they need to make sure they stay visible:
 * 1. Focusable node newly receives focus â€“ always bring entire node into view.
 * 2. Unfocused text field is tapped â€“ always bring cursor area into view (conflicts with above, see
 *    b/216790855).
 * 3. Focused text field is tapped â€“ always bring cursor area into view.
 * 4. Text input occurs â€“ always bring cursor area into view.
 * 5. Scrollable parent resizes and the currently-focused item is now hidden â€“ bring entire node
 *    into view if it was also in view before the resize. This handles the case of
 *    `softInputMode=ADJUST_RESIZE`. See b/216842427.
 * 6. Entire window is panned due to `softInputMode=ADJUST_PAN` â€“ report the correct focused rect to
 *    the view system, and the view system itself will keep the focused area in view. See
 *    aosp/1964580.
 *
 * This function is used to handle 2, 3, and 4, and the others are automatically handled by the
 * focus system.
 */
internal suspend fun BringIntoViewRequester.bringSelectionEndIntoView(
    value: TextFieldValue,
    textDelegate: TextDelegate,
    textLayoutResult: TextLayoutResult,
    offsetMapping: OffsetMapping
) {
    val selectionEndInTransformed = offsetMapping.originalToTransformed(value.selection.max)
    val selectionEndBounds =
        when {
            selectionEndInTransformed < textLayoutResult.layoutInput.text.length -> {
                textLayoutResult.getBoundingBox(selectionEndInTransformed)
            }
            selectionEndInTransformed != 0 -> {
                textLayoutResult.getBoundingBox(selectionEndInTransformed - 1)
            }
            else -> { // empty text.
                val defaultSize =
                    computeSizeForDefaultText(
                        textDelegate.style,
                        textDelegate.density,
                        textDelegate.fontFamilyResolver
                    )
                Rect(0f, 0f, 1.0f, defaultSize.height.toFloat())
            }
        }
    bringIntoView(selectionEndBounds)
}

@Composable
private fun SelectionToolbarAndHandles(manager: TextFieldSelectionManager, show: Boolean) {
    with(manager) {
        if (show) {
            // Check whether text layout result became stale. A stale text layout might be
            // completely unrelated to current TextFieldValue, causing offset errors.
            state
                ?.layoutResult
                ?.value
                ?.takeIf { !(state?.isLayoutResultStale ?: true) }
                ?.let {
                    if (!value.selection.collapsed) {
                        val startOffset = offsetMapping.originalToTransformed(value.selection.start)
                        val endOffset = offsetMapping.originalToTransformed(value.selection.end)
                        val startDirection = it.getBidiRunDirection(startOffset)
                        val endDirection = it.getBidiRunDirection(max(endOffset - 1, 0))
                        if (manager.state?.showSelectionHandleStart == true) {
                            TextFieldSelectionHandle(
                                isStartHandle = true,
                                direction = startDirection,
                                manager = manager
                            )
                        }
                        if (manager.state?.showSelectionHandleEnd == true) {
                            TextFieldSelectionHandle(
                                isStartHandle = false,
                                direction = endDirection,
                                manager = manager
                            )
                        }
                    }

                    state?.let { textFieldState ->
                        // If in selection mode (when the floating toolbar is shown) a new symbol
                        // from the keyboard is entered, text field should enter the editing mode
                        // instead.
                        if (isTextChanged()) textFieldState.showFloatingToolbar = false
                        if (textFieldState.hasFocus) {
                            if (textFieldState.showFloatingToolbar) showSelectionToolbar()
                            else hideSelectionToolbar()
                        }
                    }
                }
        } else hideSelectionToolbar()
    }
}

@Composable
internal fun TextFieldCursorHandle(manager: TextFieldSelectionManager) {
    if (manager.state?.showCursorHandle == true && manager.transformedText?.isNotEmpty() == true) {
        val observer = remember(manager) { manager.cursorDragObserver() }
        val position = manager.getCursorPosition(LocalDensity.current)
        CursorHandle(
            offsetProvider = { position },
            modifier =
                Modifier.pointerInput(observer) {
                    coroutineScope {
                        // UNDISPATCHED because this runs upon first pointer event and
                        // without it the event would pass before the handler is ready
                        launch(start = CoroutineStart.UNDISPATCHED) {
                            detectDownAndDragGesturesWithObserver(observer)
                        }
                        launch(start = CoroutineStart.UNDISPATCHED) {
                            detectTapGestures { manager.showSelectionToolbar() }
                        }
                    }
                }
                    .semantics {
                        this[SelectionHandleInfoKey] =
                            SelectionHandleInfo(
                                handle = Handle.Cursor,
                                position = position,
                                anchor = SelectionHandleAnchor.Middle,
                                visible = true,
                            )
                    }
        )
    }
}

// TODO(b/262648050) Try to find a better API.
private fun notifyFocusedRect(
    state: LegacyTextFieldState,
    value: TextFieldValue,
    offsetMapping: OffsetMapping
) {
    // If this reports state reads it causes an invalidation cycle.
    // This function doesn't need to be invalidated anyway because it's already explicitly called
    // after updating text layout or position.
    Snapshot.withoutReadObservation {
        val layoutResult = state.layoutResult ?: return
        val inputSession = state.inputSession ?: return
        val layoutCoordinates = state.layoutCoordinates ?: return
        TextFieldDelegate.notifyFocusedRect(
            value,
            state.textDelegate,
            layoutResult.value,
            layoutCoordinates,
            inputSession,
            state.hasFocus,
            offsetMapping
        )
    }
}

internal class TextFieldSelectionManager(val undoManager: UndoManager? = null) {

    /** The current [OffsetMapping] for text field. */
    internal var offsetMapping: OffsetMapping = ValidatingEmptyOffsetMappingIdentity

    /** Called when the input service updates the values in [TextFieldValue]. */
    internal var onValueChange: (TextFieldValue) -> Unit = {}

    /** The current [LegacyTextFieldState]. */
    internal var state: LegacyTextFieldState? = null

    /**
     * The current [TextFieldValue]. This contains the original text, not the transformed text.
     * Transformed text can be found with [transformedText].
     */
    internal var value: TextFieldValue by mutableStateOf(TextFieldValue())

    /**
     * The current transformed text from the [LegacyTextFieldState]. The original text can be found
     * in [value].
     */
    internal val transformedText
        get() = state?.textDelegate?.text

    /**
     * Visual transformation of the text field's text. Used to check if certain toolbar options are
     * permitted. For example, 'cut' will not be available is it is password transformation.
     */
    internal var visualTransformation: VisualTransformation = VisualTransformation.None

    /** The action to invoke when autofill is requested in text toolbar. */
    internal var requestAutofillAction: (() -> Unit)? = null

    /** [Clipboard] to perform clipboard features. */
    internal var clipboard: Clipboard? = null

    /** [CoroutineScope] to perform clipboard features */
    internal var coroutineScope: CoroutineScope? = null

    /** [TextToolbar] to show floating toolbar(post-M) or primary toolbar(pre-M). */
    var textToolbar: TextToolbar? = null

    /** [HapticFeedback] handle to perform haptic feedback. */
    var hapticFeedBack: HapticFeedback? = null

    /** [FocusRequester] used to request focus for the TextField. */
    var focusRequester: FocusRequester? = null

    /** Defines if paste and cut toolbar menu actions should be shown */
    var editable by mutableStateOf(true)

    /** Whether the text field should be selectable at all. */
    var enabled by mutableStateOf(true)

    /**
     * The beginning position of the drag gesture. Every time a new drag gesture starts, it wil be
     * recalculated.
     */
    private var dragBeginPosition = Offset.Zero

    /**
     * The beginning offset of the drag gesture translated into position in text. Every time a new
     * drag gesture starts, it wil be recalculated. Unlike [dragBeginPosition] that is relative to
     * the decoration box, [dragBeginOffsetInText] represents index in text. Essentially, it is
     * equal to `layoutResult.getOffsetForPosition(dragBeginPosition)`.
     */
    private var dragBeginOffsetInText: Int? = null

    /**
     * The total distance being dragged of the drag gesture. Every time a new drag gesture starts,
     * it will be zeroed out.
     */
    private var dragTotalDistance = Offset.Zero

    /**
     * A flag to check if a selection or cursor handle is being dragged, and which handle is being
     * dragged. If this value is non-null, then onPress will not select any text. This value will be
     * set to non-null when either handle is being dragged, and be reset to null when the dragging
     * is stopped.
     */
    var draggingHandle: Handle? by mutableStateOf(null)
        internal set

    /** The current position of a drag, in decoration box coordinates. */
    var currentDragPosition: Offset? by mutableStateOf(null)
        internal set

    /**
     * The previous offset of a drag, before selection adjustments. Only update when a selection
     * layout change has occurred, or set to -1 if a new drag begins.
     */
    internal var previousRawDragOffset: Int = -1

    /**
     * The old [TextFieldValue] before entering the selection mode on long press. Used to exit the
     * selection mode.
     */
    private var oldValue: TextFieldValue = TextFieldValue()

    /** The previous [SelectionLayout] where [SelectionLayout.shouldRecomputeSelection] was true. */
    internal var previousSelectionLayout: SelectionLayout? = null

    /** [TextDragObserver] for long press and drag to select in TextField. */
    internal val touchSelectionObserver =
        object : TextDragObserver {
            override fun onDown(point: Offset) {
                // Not supported for long-press-drag.
            }

            override fun onUp() {
                // Nothing to do.
            }

            override fun onStart(startPoint: Offset) {
                if (!enabled || draggingHandle != null) return
                // While selecting by long-press-dragging, the "end" of the selection is always the
                // one
                // being controlled by the drag.
                draggingHandle = Handle.SelectionEnd
                previousRawDragOffset = -1

                // ensuring that current action mode (selection toolbar) is invalidated
                hideSelectionToolbar()

                // Long Press at the blank area, the cursor should show up at the end of the line.
                if (state?.layoutResult?.isPositionOnText(startPoint) != true) {
                    state?.layoutResult?.let { layoutResult ->
                        val transformedOffset = layoutResult.getOffsetForPosition(startPoint)
                        val offset = offsetMapping.transformedToOriginal(transformedOffset)

                        val newValue =
                            createTextFieldValue(
                                annotatedString = value.annotatedString,
                                selection = TextRange(offset, offset)
                            )

                        enterSelectionMode(showFloatingToolbar = false)
                        hapticFeedBack?.performHapticFeedback(HapticFeedbackType.TextHandleMove)
                        onValueChange(newValue)
                    }
                } else {
                    if (value.text.isEmpty()) return
                    enterSelectionMode(showFloatingToolbar = false)
                    val adjustedStartSelection =
                        updateSelection(
                            // reset selection, otherwise a previous selection may be used
                            // as context for creating the next selection
                            value = value.copy(selection = TextRange.Zero),
                            currentPosition = startPoint,
                            isStartOfSelection = true,
                            isStartHandle = false,
                            adjustment = SelectionAdjustment.Word,
                            isTouchBasedSelection = true,
                        )
                    // For touch, set the begin offset to the adjusted selection.
                    // When char based selection is used, we want to ensure we snap the
                    // beginning offset to the start word boundary of the first selected word.
                    dragBeginOffsetInText = adjustedStartSelection.start
                }

                // don't set selection handle state until drag ends
                setHandleState(None)

                dragBeginPosition = startPoint
                currentDragPosition = dragBeginPosition
                dragTotalDistance = Offset.Zero
            }

            override fun onDrag(delta: Offset) {
                // selection never started, did not consume any drag
                if (!enabled || value.text.isEmpty()) return

                dragTotalDistance += delta
                state?.layoutResult?.let { layoutResult ->
                    currentDragPosition = dragBeginPosition + dragTotalDistance

                    if (
                        dragBeginOffsetInText == null &&
                        !layoutResult.isPositionOnText(currentDragPosition!!)
                    ) {
                        // both start and end of drag is in end padding.
                        val startOffset =
                            offsetMapping.transformedToOriginal(
                                layoutResult.getOffsetForPosition(dragBeginPosition)
                            )

                        val endOffset =
                            offsetMapping.transformedToOriginal(
                                layoutResult.getOffsetForPosition(currentDragPosition!!)
                            )

                        val adjustment =
                            if (startOffset == endOffset) {
                                // start and end is in the same end padding, keep the collapsed
                                // selection
                                SelectionAdjustment.None
                            } else {
                                SelectionAdjustment.Word
                            }

                        updateSelection(
                            value = value,
                            currentPosition = currentDragPosition!!,
                            isStartOfSelection = false,
                            isStartHandle = false,
                            adjustment = adjustment,
                            isTouchBasedSelection = true,
                        )
                    } else {
                        val startOffset =
                            dragBeginOffsetInText
                                ?: layoutResult.getOffsetForPosition(
                                    position = dragBeginPosition,
                                    coerceInVisibleBounds = false
                                )
                        val endOffset =
                            layoutResult.getOffsetForPosition(
                                position = currentDragPosition!!,
                                coerceInVisibleBounds = false
                            )

                        if (dragBeginOffsetInText == null && startOffset == endOffset) {
                            // if we are selecting starting from end padding,
                            // don't start selection until we have and un-collapsed selection.
                            return
                        }

                        updateSelection(
                            value = value,
                            currentPosition = currentDragPosition!!,
                            isStartOfSelection = false,
                            isStartHandle = false,
                            adjustment = SelectionAdjustment.Word,
                            isTouchBasedSelection = true,
                        )
                    }
                }
                updateFloatingToolbar(show = false)
            }

            override fun onStop() = onEnd()

            override fun onCancel() = onEnd()

            private fun onEnd() {
                draggingHandle = null
                currentDragPosition = null
                updateFloatingToolbar(show = true)
                dragBeginOffsetInText = null

                val collapsed = value.selection.collapsed
                setHandleState(if (collapsed) Cursor else Selection)
                state?.showSelectionHandleStart =
                    !collapsed && isSelectionHandleInVisibleBound(isStartHandle = true)
                state?.showSelectionHandleEnd =
                    !collapsed && isSelectionHandleInVisibleBound(isStartHandle = false)
                state?.showCursorHandle =
                    collapsed && isSelectionHandleInVisibleBound(isStartHandle = true)
            }
        }

    internal val mouseSelectionObserver =
        object : MouseSelectionObserver {
            override fun onExtend(downPosition: Offset): Boolean {
                // can't update selection without a layoutResult, so don't consume
                state?.layoutResult ?: return false
                if (!enabled) return false
                previousRawDragOffset = -1
                updateMouseSelection(
                    value = value,
                    currentPosition = downPosition,
                    isStartOfSelection = false,
                    adjustment = SelectionAdjustment.None,
                )
                return true
            }

            override fun onExtendDrag(dragPosition: Offset): Boolean {
                if (!enabled || value.text.isEmpty()) return false
                // can't update selection without a layoutResult, so don't consume
                state?.layoutResult ?: return false

                updateMouseSelection(
                    value = value,
                    currentPosition = dragPosition,
                    isStartOfSelection = false,
                    adjustment = SelectionAdjustment.None,
                )
                return true
            }

            override fun onStart(downPosition: Offset, adjustment: SelectionAdjustment): Boolean {
                if (!enabled || value.text.isEmpty()) return false
                // can't update selection without a layoutResult, so don't consume
                state?.layoutResult ?: return false

                focusRequester?.requestFocus()
                dragBeginPosition = downPosition
                previousRawDragOffset = -1
                enterSelectionMode()
                updateMouseSelection(
                    value = value,
                    currentPosition = dragBeginPosition,
                    isStartOfSelection = true,
                    adjustment = adjustment,
                )
                return true
            }

            override fun onDrag(dragPosition: Offset, adjustment: SelectionAdjustment): Boolean {
                if (!enabled || value.text.isEmpty()) return false
                // can't update selection without a layoutResult, so don't consume
                state?.layoutResult ?: return false

                updateMouseSelection(
                    value = value,
                    currentPosition = dragPosition,
                    isStartOfSelection = false,
                    adjustment = adjustment,
                )
                return true
            }

            fun updateMouseSelection(
                value: TextFieldValue,
                currentPosition: Offset,
                isStartOfSelection: Boolean,
                adjustment: SelectionAdjustment,
            ) {
                val newSelection =
                    updateSelection(
                        value = value,
                        currentPosition = currentPosition,
                        isStartOfSelection = isStartOfSelection,
                        isStartHandle = false,
                        adjustment = adjustment,
                        isTouchBasedSelection = false,
                    )
                setHandleState(if (newSelection.collapsed) Cursor else Selection)
            }

            override fun onDragDone() {
                /* Nothing to do */
            }
        }

    /**
     * [TextDragObserver] for dragging the selection handles to change the selection in TextField.
     */
    internal fun handleDragObserver(isStartHandle: Boolean): TextDragObserver =
        object : TextDragObserver {
            override fun onDown(point: Offset) {
                draggingHandle = if (isStartHandle) Handle.SelectionStart else Handle.SelectionEnd

                // The position of the character where the drag gesture should begin. This is in
                // the inner text field coordinates.
                val handleCoordinates = getAdjustedCoordinates(getHandlePosition(isStartHandle))

                // translate to decoration box coordinates
                val layoutResult = state?.layoutResult ?: return
                val translatedPosition =
                    layoutResult.translateInnerToDecorationCoordinates(handleCoordinates)

                dragBeginPosition = translatedPosition
                currentDragPosition = translatedPosition

                // Zero out the total distance that being dragged.
                dragTotalDistance = Offset.Zero
                previousRawDragOffset = -1

                state?.isInTouchMode = true
                updateFloatingToolbar(show = false)
            }

            override fun onUp() {
                draggingHandle = null
                currentDragPosition = null
                updateFloatingToolbar(show = true)
            }

            override fun onStart(startPoint: Offset) {
                // handled in onDown
            }

            override fun onDrag(delta: Offset) {
                dragTotalDistance += delta

                currentDragPosition = dragBeginPosition + dragTotalDistance
                updateSelection(
                    value = value,
                    currentPosition = currentDragPosition!!,
                    isStartOfSelection = false,
                    isStartHandle = isStartHandle,
                    adjustment = SelectionAdjustment.CharacterWithWordAccelerate,
                    isTouchBasedSelection = true, // handle drag infers touch
                )
                updateFloatingToolbar(show = false)
            }

            override fun onStop() {
                draggingHandle = null
                currentDragPosition = null
                updateFloatingToolbar(show = true)
            }

            override fun onCancel() {
                draggingHandle = null
                currentDragPosition = null
            }
        }

    /** [TextDragObserver] for dragging the cursor to change the selection in TextField. */
    internal fun cursorDragObserver(): TextDragObserver =
        object : TextDragObserver {
            override fun onDown(point: Offset) {
                // Nothing
            }

            override fun onUp() {
                draggingHandle = null
                currentDragPosition = null
            }

            override fun onStart(startPoint: Offset) {
                // The position of the character where the drag gesture should begin. This is in
                // the inner text field coordinates.
                val handleCoordinates = getAdjustedCoordinates(getHandlePosition(true))

                // translate to decoration box coordinates
                val layoutResult = state?.layoutResult ?: return
                val translatedPosition =
                    layoutResult.translateInnerToDecorationCoordinates(handleCoordinates)

                dragBeginPosition = translatedPosition
                currentDragPosition = translatedPosition
                // Zero out the total distance that being dragged.
                dragTotalDistance = Offset.Zero
                draggingHandle = Handle.Cursor
                updateFloatingToolbar(show = false)
            }

            override fun onDrag(delta: Offset) {
                dragTotalDistance += delta

                state?.layoutResult?.let { layoutResult ->
                    currentDragPosition = dragBeginPosition + dragTotalDistance
                    val offset =
                        offsetMapping.transformedToOriginal(
                            layoutResult.getOffsetForPosition(currentDragPosition!!)
                        )

                    val newSelection = TextRange(offset, offset)

                    // Nothing changed, skip onValueChange hand hapticFeedback.
                    if (newSelection == value.selection) return

                    if (state?.isInTouchMode != false) {
                        hapticFeedBack?.performHapticFeedback(HapticFeedbackType.TextHandleMove)
                    }

                    onValueChange(
                        createTextFieldValue(
                            annotatedString = value.annotatedString,
                            selection = newSelection
                        )
                    )
                }
            }

            override fun onStop() {
                draggingHandle = null
                currentDragPosition = null
            }

            override fun onCancel() {}
        }

    /**
     * The method to record the required state values on entering the selection mode.
     *
     * Is triggered on long press or accessibility action.
     *
     * @param showFloatingToolbar whether to show the floating toolbar when entering selection mode
     */
    internal fun enterSelectionMode(showFloatingToolbar: Boolean = true) {
        if (state?.hasFocus == false) {
            focusRequester?.requestFocus()
        }
        oldValue = value
        updateFloatingToolbar(showFloatingToolbar)
        setHandleState(Selection)
    }

    /**
     * The method to record the corresponding state values on exiting the selection mode.
     *
     * Is triggered on accessibility action.
     */
    internal fun exitSelectionMode() {
        updateFloatingToolbar(show = false)
        setHandleState(None)
    }

    internal fun deselect(position: Offset? = null) {
        if (!value.selection.collapsed) {
            // if selection was not collapsed, set a default cursor location, otherwise
            // don't change the location of the cursor.
            val layoutResult = state?.layoutResult
            val newCursorOffset =
                if (position != null && layoutResult != null) {
                    offsetMapping.transformedToOriginal(layoutResult.getOffsetForPosition(position))
                } else {
                    value.selection.max
                }
            val newValue = value.copy(selection = TextRange(newCursorOffset))
            onValueChange(newValue)
        }

        // If a new cursor position is given and the text is not empty, enter the Cursor state.
        val selectionMode = if (position != null && value.text.isNotEmpty()) Cursor else None
        setHandleState(selectionMode)
        updateFloatingToolbar(show = false)
    }

    internal fun setSelectionPreviewHighlight(range: TextRange) {
        state?.selectionPreviewHighlightRange = range
        state?.deletionPreviewHighlightRange = TextRange.Zero
        if (!range.collapsed) exitSelectionMode()
    }

    internal fun setDeletionPreviewHighlight(range: TextRange) {
        state?.deletionPreviewHighlightRange = range
        state?.selectionPreviewHighlightRange = TextRange.Zero
        if (!range.collapsed) exitSelectionMode()
    }

    internal fun clearPreviewHighlight() {
        state?.deletionPreviewHighlightRange = TextRange.Zero
        state?.selectionPreviewHighlightRange = TextRange.Zero
    }

    /**
     * The method for copying text.
     *
     * If there is no selection, return. Put the selected text into the [Clipboard], and cancel the
     * selection, if [cancelSelection] is true. The text in the text field should be unchanged. If
     * [cancelSelection] is true, the new cursor offset should be at the end of the previous
     * selected text.
     */
    internal fun copy(cancelSelection: Boolean = true) =
        coroutineScope?.launch(start = CoroutineStart.UNDISPATCHED) {
            if (value.selection.collapsed) return@launch

            // TODO(b/171947959) check if original or transformed should be copied
            clipboard?.setClipEntry(value.getSelectedText().toClipEntry())

            if (!cancelSelection) return@launch

            val newCursorOffset = value.selection.max
            val newValue =
                createTextFieldValue(
                    annotatedString = value.annotatedString,
                    selection = TextRange(newCursorOffset, newCursorOffset)
                )
            onValueChange(newValue)
            setHandleState(None)
        }

    internal fun onCopyWithResult(cancelSelection: Boolean = true): String? {
        if (value.selection.collapsed) return null
        val selectedText = value.getSelectedText().text

        if (!cancelSelection) return selectedText

        val newCursorOffset = value.selection.max
        val newValue = createTextFieldValue(
            annotatedString = value.annotatedString,
            selection = TextRange(newCursorOffset, newCursorOffset)
        )
        onValueChange(newValue)
        setHandleState(HandleState.None)
        return selectedText
    }

    /**
     * The method for pasting text.
     *
     * Get the text from [Clipboard]. If it's null, return. The new text should be the text before
     * the selected text, plus the text from the [Clipboard], and plus the text after the selected
     * text. Then the selection should collapse, and the new cursor offset should be the end of the
     * newly added text.
     */
    internal fun paste() =
        coroutineScope?.launch(start = CoroutineStart.UNDISPATCHED) {
            val text = clipboard?.getClipEntry()?.readAnnotatedString() ?: return@launch

            val newText =
                value.getTextBeforeSelection(value.text.length) +
                        text +
                        value.getTextAfterSelection(value.text.length)
            val newCursorOffset = value.selection.min + text.length

            val newValue =
                createTextFieldValue(
                    annotatedString = newText,
                    selection = TextRange(newCursorOffset, newCursorOffset)
                )
            onValueChange(newValue)
            setHandleState(None)
            undoManager?.forceNextSnapshot()
        }

    internal fun paste(text: AnnotatedString) {
        val newText = value.getTextBeforeSelection(value.text.length) +
                text +
                value.getTextAfterSelection(value.text.length)
        val newCursorOffset = value.selection.min + text.length

        val newValue = createTextFieldValue(
            annotatedString = newText,
            selection = TextRange(newCursorOffset, newCursorOffset)
        )
        onValueChange(newValue)
        setHandleState(HandleState.None)
        undoManager?.forceNextSnapshot()
    }

    /**
     * The method for cutting text.
     *
     * If there is no selection, return. Put the selected text into the [Clipboard]. The new text
     * should be the text before the selection plus the text after the selection. And the new cursor
     * offset should be between the text before the selection, and the text after the selection.
     */
    internal fun cut() =
        coroutineScope?.launch(start = CoroutineStart.UNDISPATCHED) {
            if (value.selection.collapsed) return@launch

            // TODO(b/171947959) check if original or transformed should be cut
            clipboard?.setClipEntry(value.getSelectedText().toClipEntry())

            val newText =
                value.getTextBeforeSelection(value.text.length) +
                        value.getTextAfterSelection(value.text.length)
            val newCursorOffset = value.selection.min

            val newValue =
                createTextFieldValue(
                    annotatedString = newText,
                    selection = TextRange(newCursorOffset, newCursorOffset)
                )
            onValueChange(newValue)
            setHandleState(None)
            undoManager?.forceNextSnapshot()
        }

    internal fun onCutWithResult(): String? {
        if (value.selection.collapsed) return null
        val selectedText = value.getSelectedText().text

        val newText = value.getTextBeforeSelection(value.text.length) +
                value.getTextAfterSelection(value.text.length)
        val newCursorOffset = value.selection.min

        val newValue = createTextFieldValue(
            annotatedString = newText,
            selection = TextRange(newCursorOffset, newCursorOffset)
        )
        onValueChange(newValue)
        setHandleState(HandleState.None)
        undoManager?.forceNextSnapshot()

        return selectedText
    }

    /*@VisibleForTesting*/
    internal fun selectAll() {
        val newValue =
            createTextFieldValue(
                annotatedString = value.annotatedString,
                selection = TextRange(0, value.text.length)
            )
        onValueChange(newValue)
        oldValue = oldValue.copy(selection = newValue.selection)
        enterSelectionMode(showFloatingToolbar = true)
    }

    internal fun autofill() {
        requestAutofillAction?.invoke()
    }

    internal fun getHandlePosition(isStartHandle: Boolean): Offset {
        val textLayoutResult = state?.layoutResult?.value ?: return Offset.Unspecified

        // If layout and value are out of sync, return unspecified.
        // This will be called again once they are in sync.
        val transformedText = transformedText ?: return Offset.Unspecified
        val layoutInputText = textLayoutResult.layoutInput.text.text
        if (transformedText.text != layoutInputText) return Offset.Unspecified

        val offset = if (isStartHandle) value.selection.start else value.selection.end
        return getSelectionHandleCoordinates(
            textLayoutResult = textLayoutResult,
            offset = offsetMapping.originalToTransformed(offset),
            isStart = isStartHandle,
            areHandlesCrossed = value.selection.reversed
        )
    }

    internal fun getHandleLineHeight(isStartHandle: Boolean): Float {
        val offset = if (isStartHandle) value.selection.start else value.selection.end
        return state?.layoutResult?.value?.getLineHeight(offset) ?: return 0f
    }

    internal fun getCursorPosition(density: Density): Offset {
        val offset = offsetMapping.originalToTransformed(value.selection.start)
        val layoutResult = state?.layoutResult!!.value
        val cursorRect =
            layoutResult.getCursorRect(offset.coerceIn(0, layoutResult.layoutInput.text.length))
        val x = with(density) { cursorRect.left + DefaultCursorThickness.toPx() / 2 }
        return Offset(x, cursorRect.bottom)
    }

    /**
     * Update the [LegacyTextFieldState.showFloatingToolbar] state and show/hide the toolbar.
     *
     * You may want to call [showSelectionToolbar] and [hideSelectionToolbar] directly without
     * updating the [LegacyTextFieldState.showFloatingToolbar] if you are simply hiding all touch
     * selection behaviors (toolbar, handles, cursor, magnifier), but want the toolbar to come back
     * when you un-hide all those behaviors.
     */
    private fun updateFloatingToolbar(show: Boolean) {
        state?.showFloatingToolbar = show
        if (show) showSelectionToolbar() else hideSelectionToolbar()
    }

    /**
     * This function get the selected region as a Rectangle region, and pass it to [TextToolbar] to
     * make the FloatingToolbar show up in the proper place. In addition, this function passes the
     * copy, paste and cut method as callbacks when "copy", "cut" or "paste" is clicked.
     */
    internal fun showSelectionToolbar() =
        coroutineScope?.launch(start = CoroutineStart.UNDISPATCHED) {
            if (!enabled || state?.isInTouchMode == false) return@launch
            val isPassword = visualTransformation is PasswordVisualTransformation
            val copy: (() -> Unit)? =
                if (!value.selection.collapsed && !isPassword) {
                    {
                        coroutineScope?.launch(start = CoroutineStart.UNDISPATCHED) { copy() }
                        hideSelectionToolbar()
                    }
                } else null

            val cut: (() -> Unit)? =
                if (!value.selection.collapsed && editable && !isPassword) {
                    {
                        coroutineScope?.launch(start = CoroutineStart.UNDISPATCHED) { cut() }
                        hideSelectionToolbar()
                    }
                } else null

            val paste: (() -> Unit)? =
                if (editable && clipboard?.getClipEntry()?.hasText() == true) {
                    {
                        coroutineScope?.launch(start = CoroutineStart.UNDISPATCHED) { paste() }
                        hideSelectionToolbar()
                    }
                } else null

            val selectAll: (() -> Unit)? =
                if (value.selection.length != value.text.length) {
                    { selectAll() }
                } else null

            val autofill: (() -> Unit)? =
                if (editable && value.selection.collapsed) {
                    { autofill() }
                } else null

            textToolbar?.showMenu(
                rect = getContentRect(),
                onCopyRequested = copy,
                onPasteRequested = paste,
                onCutRequested = cut,
                onSelectAllRequested = selectAll,
                onAutofillRequested = autofill
            )
        }

    internal fun hideSelectionToolbar() {
        if (textToolbar?.status == TextToolbarStatus.Shown) {
            textToolbar?.hide()
        }
    }

    /**
     * Implements the macOS select-word-on-right-click behavior.
     *
     * If the current selection does not already include [position], select the word at [position].
     */
    fun selectWordAtPositionIfNotAlreadySelected(position: Offset) {
        val layoutResult = state?.layoutResult ?: return
        val isClickedPositionInsideSelection =
            layoutResult.value.isPositionInsideSelection(
                position = layoutResult.translateDecorationToInnerCoordinates(position),
                selectionRange = value.selection,
            )
        if (!isClickedPositionInsideSelection) {
            updateSelection(
                value = value,
                currentPosition = position,
                isStartOfSelection = true,
                isStartHandle = false,
                adjustment = SelectionAdjustment.Word,
                isTouchBasedSelection = false,
            )
        }
    }

    /**
     * Check if the text in the text field changed. When the content in the text field is modified,
     * this method returns true.
     */
    internal fun isTextChanged(): Boolean {
        return oldValue.text != value.text
    }

    /**
     * Calculate selected region as [Rect]. The top is the top of the first selected line, and the
     * bottom is the bottom of the last selected line. The left is the leftmost handle's horizontal
     * coordinates, and the right is the rightmost handle's coordinates.
     */
    private fun getContentRect(): Rect {
        // if it's stale layout, return empty Rect
        state
            ?.takeIf { !it.isLayoutResultStale }
            ?.let {
                // value.selection is from the original representation.
                // we need to convert original offsets into transformed offsets to query
                // layoutResult because layoutResult belongs to the transformed text.
                val transformedStart = offsetMapping.originalToTransformed(value.selection.start)
                val transformedEnd = offsetMapping.originalToTransformed(value.selection.end)
                val startOffset =
                    state?.layoutCoordinates?.localToRoot(getHandlePosition(true)) ?: Offset.Zero
                val endOffset =
                    state?.layoutCoordinates?.localToRoot(getHandlePosition(false)) ?: Offset.Zero
                val startTop =
                    state
                        ?.layoutCoordinates
                        ?.localToRoot(
                            Offset(
                                0f,
                                it.layoutResult?.value?.getCursorRect(transformedStart)?.top ?: 0f
                            )
                        )
                        ?.y ?: 0f
                val endTop =
                    state
                        ?.layoutCoordinates
                        ?.localToRoot(
                            Offset(
                                x = 0f,
                                y = it.layoutResult?.value?.getCursorRect(transformedEnd)?.top ?: 0f
                            )
                        )
                        ?.y ?: 0f

                val left = min(startOffset.x, endOffset.x)
                val right = max(startOffset.x, endOffset.x)
                val top = min(startTop, endTop)
                val bottom =
                    max(startOffset.y, endOffset.y) + 25.dp.value * it.textDelegate.density.density

                return Rect(left, top, right, bottom)
            }

        return Rect.Zero
    }

    /**
     * Update the text field's selection based on new offsets.
     *
     * @param value the current [TextFieldValue]
     * @param currentPosition the current position of the cursor/drag in the decoration box
     *   coordinates
     * @param isStartOfSelection whether this is the first updateSelection of a selection gesture.
     *   If true, will ignore any previous selection context.
     * @param isStartHandle whether the start handle is being updated
     * @param adjustment The selection adjustment to use
     * @param isTouchBasedSelection Whether this is a touch based selection
     */
    private fun updateSelection(
        value: TextFieldValue,
        currentPosition: Offset,
        isStartOfSelection: Boolean,
        isStartHandle: Boolean,
        adjustment: SelectionAdjustment,
        isTouchBasedSelection: Boolean,
    ): TextRange {
        val layoutResult = state?.layoutResult ?: return TextRange.Zero
        val previousTransformedSelection =
            TextRange(
                offsetMapping.originalToTransformed(value.selection.start),
                offsetMapping.originalToTransformed(value.selection.end)
            )

        val currentOffset =
            layoutResult.getOffsetForPosition(
                position = currentPosition,
                coerceInVisibleBounds = false
            )

        val rawStartHandleOffset =
            if (isStartHandle || isStartOfSelection) currentOffset
            else previousTransformedSelection.start

        val rawEndHandleOffset =
            if (!isStartHandle || isStartOfSelection) currentOffset
            else previousTransformedSelection.end

        val previousSelectionLayout = previousSelectionLayout // for smart cast
        val rawPreviousHandleOffset =
            if (
                isStartOfSelection || previousSelectionLayout == null || previousRawDragOffset == -1
            ) {
                -1
            } else {
                previousRawDragOffset
            }

        val selectionLayout =
            getTextFieldSelectionLayout(
                layoutResult = layoutResult.value,
                rawStartHandleOffset = rawStartHandleOffset,
                rawEndHandleOffset = rawEndHandleOffset,
                rawPreviousHandleOffset = rawPreviousHandleOffset,
                previousSelectionRange = previousTransformedSelection,
                isStartOfSelection = isStartOfSelection,
                isStartHandle = isStartHandle,
            )

        if (!selectionLayout.shouldRecomputeSelection(previousSelectionLayout)) {
            return value.selection
        }

        this.previousSelectionLayout = selectionLayout
        previousRawDragOffset = currentOffset

        val newTransformedSelection = adjustment.adjust(selectionLayout)
        val newSelection =
            TextRange(
                start = offsetMapping.transformedToOriginal(newTransformedSelection.start.offset),
                end = offsetMapping.transformedToOriginal(newTransformedSelection.end.offset)
            )

        if (newSelection == value.selection) return value.selection

        val onlyChangeIsReversed =
            newSelection.reversed != value.selection.reversed &&
                    with(newSelection) { TextRange(end, start) } == value.selection

        val bothSelectionsCollapsed = newSelection.collapsed && value.selection.collapsed
        if (
            isTouchBasedSelection &&
            value.text.isNotEmpty() &&
            !onlyChangeIsReversed &&
            !bothSelectionsCollapsed
        ) {
            hapticFeedBack?.performHapticFeedback(HapticFeedbackType.TextHandleMove)
        }

        val newValue =
            createTextFieldValue(annotatedString = value.annotatedString, selection = newSelection)
        onValueChange(newValue)

        if (!isTouchBasedSelection) {
            updateFloatingToolbar(show = !newSelection.collapsed)
        }

        state?.isInTouchMode = isTouchBasedSelection

        // showSelectionHandleStart/End might be set to false when scrolled out of the view.
        // When the selection is updated, they must also be updated so that handles will be shown
        // or hidden correctly.
        state?.showSelectionHandleStart =
            !newSelection.collapsed && isSelectionHandleInVisibleBound(isStartHandle = true)
        state?.showSelectionHandleEnd =
            !newSelection.collapsed && isSelectionHandleInVisibleBound(isStartHandle = false)
        state?.showCursorHandle =
            newSelection.collapsed && isSelectionHandleInVisibleBound(isStartHandle = true)

        return newSelection
    }

    private fun setHandleState(handleState: HandleState) {
        state?.takeUnless { it.handleState == handleState }?.let { it.handleState = handleState }
    }

    private fun createTextFieldValue(
        annotatedString: AnnotatedString,
        selection: TextRange
    ): TextFieldValue {
        return TextFieldValue(annotatedString = annotatedString, selection = selection)
    }
}
